#1.绪论
##1.1计算机问题求解
用计算机解决问题分为两个阶段：

1. 程序开发者针对要解决的问题开发出相应的程序，使用者运行程序处理问题的具体事例，完成具体计算
2. 开发程序的工作只要做一次，完成的程序可以多次使用，每次处理一个问题实例

###1.1.1程序开发过程
程序开发就是根据面对的问题，最终得到一个可以解决问题的程序的工作过程，一般而言程序开发工作需要经过一系列工作阶段才能完成。

- 分析阶段：程序开发的第一步是弄清问题
- 设计阶段：问题的严格描述仍然是描述性的，而计算机求解是一个操作过程
- 编码阶段：有了解决问题的抽象计算模型，下一步采用某种适当的编程语言实现这个模型，做出一个程序
- 检查测试阶段：反复检查修改，最后得到一个可以运行的程序
- 测试/调试阶段：程序可运行并不表示就是所需的那个程序，还需要通过尝试性的运行检测是否满足需要

![](https://i.imgur.com/Thpl316.jpg)
###1.1.2一个简单的例子
需要求出任一个非负实数的平方根。该问题可以修改为：对于任意非负实数x设法找到一个非负实数y，使得|y*y-x|<e。e为事先给定的允许误差

求平方根的另一种算法称为牛顿迭代法。描述如下：

0. 对给定正实数x和允许误差e，令变量y取任意正实数如令y=x
1. 如果y*y与x足够接近，即|y*y-x|<e，计算结束并把y作为结果
2. 取z=(y+x/y)/2
3. 将z作为y的新值回到步骤1

由上定义一个python函数实现上述算法。下面是一个定义：

	def sqrt(x):
		y = 1.0
		while abs(y*y-x)>1e-6:
			y = (y+x/y)/2
		return y
##2.数据结构
数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。事实上就是

- 程序设计 = 数据结构 + 算法
- 再简单的来说数据结构就是关系，没错，就是数据元素相互之间存在的一种或多种特定关系的集合。

我们把数据结构分为逻辑结构和物理结构。

- 逻辑结构：是指数据对象中数据元素之间的相互关系，也是我们今后最需要关注和讨论的问题。
- 物理结构：是指数据的逻辑结构在计算机中的存储形式。
###2.1逻辑结构
- 集合结构 集合结构中的数据元素除了属于同一个集合外，它们之间并没有其他关系
- 线性结构 线性结构中的数据元素之间是一对一的关系
- 树形结构 数据元素之间存在一对多的层次关系
- 图形结构 图形结构的数据是多对多的关系
###2.2物理结构
根据物理结构的定义，我们实际上研究的的就是如何把数据元素存储到计算机的存储器中。存储器主要是针对内存而言的，像硬盘、软盘、光盘等外部存储器的数据组织通常用文件结构来描述。数据元素的存储结构形式有两种：顺序存储和链式存储。

- 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。
- 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。需要用一个指针存放数据元素的地址，这样子通过地址就可以找到相关联数据元素的位置
##3.算法
算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

算法具有五个基本特征：输入、输出、有穷性、确定性和可行性。
- 输入，算法具有零个或多个输入。尽管对于绝大多数算法来说，输入参数都是必要的。但是有些时候，像打印“I love fishc.com”，就不需要啥参数啦。
- 输出，算法至少有一个或多个输出。输出的形式可以是打印形式输出，也可以是返回一个值或多个值等。
- 有穷性，指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。

###3.1算法设计的要求
- 可读性 算法设计另一目的是为了便于阅读、理解和交流
- 健壮性 当输入数据不合法时，算法也能做出相关处理，而不是产生异常、崩溃或莫名其妙的结果。
- 时间效率高和存储量低 应该具备时间效率高和存储量低的特点

###3.2算法效率的度量方法
- 事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。

	有很大缺陷的：
	必须依据算法事先编制好测试程序，通常需要花费大量时间和精力，完了发觉测试的是糟糕的算法，那不是功亏一篑？赔了娘子又折兵？
	不同测试环境差别不是一般的大！
- 事前分析估算方法：在计算机程序编写前，依据统计方法对算法进行估算。经过总结，高级语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：

	1. 算法采用的策略，方案
	2. 编译产生的代码质量
	3. 问题的输入规模
	4. 机器执行指令的速度
判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高项）的阶数。

注意，判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的，很容易以偏概全。
###3.3算法时间复杂度
算法时间复杂度的定义：在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)= O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。关键需要知道执行次数==时间

这样用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优算法。

- 推导大O阶方法

	- 用常数1取代运行时间中的所有加法常数。
	- 在修改后的运行次数函数中，只保留最高阶项。
	- 如果最高阶项存在且不是1，则去除与这个项相乘的常数。
	- 得到的最后结果就是大O阶。
	举例：
		
		int sum = 0, n = 100;
		printf(“I love fishc.com\n”);
		printf(“I love Fishc.com\n”);
		printf(“I love fishC.com\n”);
		printf(“I love fIshc.com\n”);
		printf(“I love FishC.com\n”);
		printf(“I love fishc.com\n”);
		sum = (1+n)*n/2;

		攻略第一条就说明了所有加法常数给他个O(1)即可。
	举例2：

		一般含有非嵌套循环涉及线性阶，线性阶就是随着问题规模n的扩大，对应计算次数呈直线增长。
		int i , n = 100, sum = 0;
		for( i=0; i < n; i++ )
		{
			sum = sum + i;
		}
		它的循环的时间复杂度为O(n)，因为循环体中的代码需要执行n次。
	举例3：

		嵌套
		int i, j, n = 100;
		for( i=0; i < n; i++ )
		{
			for( j=0; j < n; j++ )
			{
				printf(“I love FishC.com\n”);
			}
		}
		n等于100，也就是说外层循环每执行一次，内层循环就执行100次，那总共程序想要从这两个循环出来，需要执行100*100次，也就是n的平方。所以这段代码的时间复杂度为O(n^2)。如果有三个这样的嵌套循环就是n^3啦。

	循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。
	举例4：

		int i, j, n = 100;
		for( i=0; i < n; i++ )
		{
			for( j=i; j < n; j++ )
			{
				printf(“I love FishC.com\n”);
			}
		}
		分析下，由于当i=0时，内循环执行了n次，当i=1时，内循环则执行n-1次……当i=n-1时，内循环执行1次，所以总的执行次数应该是：n+(n-1)+(n-2)+…+1 = n(n+1)/2
	
		用我们推导大O的攻略，第一条忽略，因为没有常数相加。第二条只保留最高项，所以n/2这项去掉。第三条，去除与最高项相乘的常数，最终得O(n^2)。
	举例5：
		
		int i = 1, n = 100;
		while( i < n )
		{
			i = i * 2;
		}
		由于每次i*2之后，就举例n更近一步，假设有x个2相乘后大于或等于n，则会退出循环。
		于是由2^x = n得到x = log(2)n，所以这个循环的时间复杂度为O(logn)。
###3.4函数调用的时间复杂度分析
举例1：

	int i, j;
	for(i=0; i < n; i++) {
		function(i);
	}
	void function(int count) {
		printf(“%d”, count);
	}
	function函数的时间复杂度是O(1)，所以整体的时间复杂度就是循环的次数O(n)。
举例2：

	void function(int count) {
		int j;
		for(j=count; j < n; j++) {
		    printf(“%d”, j);
		}
	}
	事实上，这和之前我们讲解平方阶的时候举的第二个例子一样：function内部的循环次数随count的增加(接近n)而减少，所以根据游戏攻略算法的时间复杂度为O(n^2)
举例3：

	n++;
	function(n);
	for(i=0; i < n; i++) {
		function(i);
	}
	for(i=0; i < n; i++) {
		for(j=i; j < n; j++) {
		    printf(“%d”, j);
		}
	}
常见的时间复杂度

	例子				时间复杂度		装逼术语
	5201314				O(1)		常数阶
	3n+4				O(n)		线性阶
	3n^2+4n+5			O(n^2)		平方阶
	3log(2)n+4			O(logn)		对数阶
	2n+3nlog(2)n+14		O(nlogn)	nlogn阶
	n^3+2n^2+4n+6		O(n^3)		立方阶
	2^n					O(2^n)		指数阶
常用的时间复杂度所耗费的时间从小到大依次是：O(1) < O(logn) < (n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
###3.5算法的空间复杂度
举个例子说，要判断某年是不是闰年，你可能会花一点心思来写一个算法，每给一个年份，就可以通过这个算法计算得到是否闰年的结果。

另外一种方法是，事先建立一个有2050个元素的数组，然后把所有的年份按下标的数字对应，如果是闰年，则此数组元素的值是1，如果不是元素的值则为0。这样，所谓的判断某一年是否为闰年就变成了查找这个数组某一个元素的值的问题。

第一种方法相比起第二种来说很明显非常节省空间，但每一次查询都需要经过一系列的计算才能知道是否为闰年。第二种方法虽然需要在内存里存储2050个元素的数组，但是每次查询只需要一次索引判断即可。

算法的空间复杂度通过计算算法所需的存储空间实现，算法的空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。
通常，我们都是用“时间复杂度”来指运行时间的需求，是用“空间复杂度”指空间需求。
当直接要让我们求“复杂度”时，通常指的是时间复杂度。
##4.线性表
###4.1线性表的定义
线性表（List）：由零个或多个数据元素组成的有限序列。
- 首先它是一个序列，也就是说元素之间是有个先来后到的
- 若元素存在多个，则第一个元素无前驱，而最后一个元素无后继，其他元素都有且只有一个前驱和后继。
- 线性表强调是有限的，事实上无论计算机发展到多强大，它所处理的元素都是有限的。

如果用数学语言来进行定义，可如下：

若将线性表记为（a1,…,ai-1,ai,ai+1,…an）,则表中ai-1领先于ai,ai领先于ai+1,称ai-1是ai的直接前驱元素,ai+1是ai的直接后继元素。

所以线性表元素的个数n(n>=0)定义为线性表的长度，当n=0时，称为空表。

###4.2抽象数据类型
数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。例如很多编程语言的整型，浮点型，字符型这些指的就是数据类型。

在C语言中，按照取值的不同，数据类型可以分为两类：

- 原子类型：不可以再分解的基本类型，例如整型、浮点型、字符型等。
- 结构类型：由若干个类型组合而成，是可以再分解的，例如整型数组是由若干整型数据组成的。

抽象：是指抽取出事物具有的普遍性的本质。它要求抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节。

我们对已有的数据类型进行抽象，就有了抽象数据类型。抽象数据类型（Abstract Data Type，ADT）是指一个数学模型及定义在该模型上的一组操作。

抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。
	比如1+1=2这样一个操作，在不同CPU的处理上可能不一样，但由于其定义的数学特性相同，所以在计算机编程者看来，它们都是相同的。

“抽象”的意义在于数据类型的数学抽象特性。而且，抽象数据类型不仅仅指那些已经定义并实现的数据类型，还可以是计算机编程者在设计软件程序时自己定义的数据类型。

为了便于在之后的讲解中对抽象数据类型进行规范的描述，我们给出了描述抽象数据类型的标准格式：

	ADT 抽象数据类型名
	Data
		数据元素之间逻辑关系的定义
	Operation
		操作
	endADT









